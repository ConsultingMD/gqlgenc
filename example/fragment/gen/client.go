// Code generated by github.com/Yamashou/gqlgenc, DO NOT EDIT.

package gen

import (
	"context"
	"net/http"

	"github.com/Yamashou/gqlgenc/clientv2"
)

type Client struct {
	Client *clientv2.Client
}

func NewClient(cli *http.Client, baseURL string, interceptors ...clientv2.RequestInterceptor) *Client {
	return &Client{Client: clientv2.NewClient(cli, baseURL, interceptors...)}
}

type Query struct {
	Conversation *Conversation "json:\"conversation\" graphql:\"conversation\""
}
type Mutation struct {
	Something string "json:\"something\" graphql:\"something\""
}
type AnswerFragment struct {
	Answer ChatSingleSelectAnswer "json:\"answer\" graphql:\"answer\""
}
type QuestionFragment struct {
	Question ChatSingleSelectQuestion "json:\"question\" graphql:\"question\""
}
type ConversationByIDQuery struct {
	Conversation *struct {
		Messages []*struct {
			Answer   ChatSingleSelectAnswer   "json:\"answer\" graphql:\"answer\""
			Question ChatSingleSelectQuestion "json:\"question\" graphql:\"question\""
		} "json:\"messages\" graphql:\"messages\""
	} "json:\"conversation\" graphql:\"conversation\""
}

const ConversationByIDQueryDocument = `query ConversationByIDQuery ($id: ID!) {
	conversation(id: $id) {
		messages {
			... answerFragment
			... questionFragment
		}
	}
}
fragment answerFragment on ChatAnswerMessage {
	answer {
		... on ChatSingleSelectAnswer {
			selectionId
		}
	}
}
fragment questionFragment on ChatQuestionMessage {
	question {
		... on ChatSingleSelectQuestion {
			options {
				id
				text
			}
		}
	}
}
`

func (c *Client) ConversationByIDQuery(ctx context.Context, id string, interceptors ...clientv2.RequestInterceptor) (*ConversationByIDQuery, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res ConversationByIDQuery
	if err := c.Client.Post(ctx, "ConversationByIDQuery", ConversationByIDQueryDocument, &res, vars, interceptors...); err != nil {
		return nil, err
	}

	return &res, nil
}
